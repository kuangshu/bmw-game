# 游戏事件系统使用说明

## 概述

本项目实现了一个基于事件驱动的游戏交互系统，用于处理游戏过程中各种需要等待玩家操作的场景。该系统通过发布/订阅模式，实现了游戏逻辑层与UI渲染层的解耦。

## 核心组件

### 1. GameEventSystem (事件系统核心类)

负责管理游戏中的各种异步事件和玩家交互。

#### 主要方法：

- `publishEvent(event: GameEventData)`: 发布事件
- `subscribe(eventType: GameEventType, callback: GameEventCallback)`: 订阅事件
- `waitForPlayerChoice<T>(event: GameEventData): Promise<T>`: 等待玩家选择并返回Promise
- `completeEvent(eventId: string, result: any)`: 完成事件处理并返回结果

### 2. GameEventType (事件类型)

定义了各种游戏事件类型：

- 法术卡事件：
  - `SPELL_FIX_DICE`: 定身术
  - `SPELL_SWAP_POSITION`: 交换位置
  - `SPELL_EXTRA_TURN`: 额外回合
  - `SPELL_SHIELD`: 护盾

- BOSS战斗事件：
  - `BOSS_BATTLE_START`: BOSS战斗开始
  - `BOSS_BATTLE_PLAY_CARDS`: BOSS战斗出牌
  - `BOSS_BATTLE_DISCARD`: BOSS战斗弃牌撤退

- 格子事件：
  - `TILE_TREASURE`: 宝箱格
  - `TILE_REVERSE`: 反转格
  - `TILE_SUPPLY`: 补给站
  - `TILE_TELEPORT`: 传送格

- 游戏事件：
  - `GAME_OVER`: 游戏结束
  - `TURN_END`: 回合结束
  - `PLAYER_CHOICE`: 玩家选择
  - `CUSTOM`: 自定义事件

### 3. GameEventData (事件数据)

包含事件的所有相关信息：

- `type`: 事件类型
- `playerId`: 玩家ID（可选）
- `timestamp`: 时间戳
- `spellCardId`: 法术卡ID（可选）
- `bossBattleData`: BOSS战斗数据（可选）
- `tileData`: 格子数据（可选）
- `customData`: 自定义数据（可选）
- `options`: 选项参数（可选）

## 使用方法

### 1. 发布事件

在游戏逻辑中，当需要玩家操作时，发布相应事件：

```typescript
// 在Game类中
const eventSystem = this._eventSystem;
eventSystem.publishEvent({
  type: "SPELL_FIX_DICE",
  playerId: player.id,
  spellCardId: cardId,
  options: {}
});
```

### 2. 订阅事件

在UI组件中订阅感兴趣的事件类型：

```typescript
// 在GameEventLayer.tsx中
useEffect(() => {
  if (!gameInstance) return;

  const eventSystem = gameInstance.eventSystem;
  
  // 订阅法术卡事件
  eventSystem.subscribe("SPELL_FIX_DICE", (eventData) => {
    // 处理定身术事件
    setCurrentEvent(eventData);
  });

  // 清理订阅
  return () => {
    eventSystem.unsubscribe("SPELL_FIX_DICE", handler);
  };
}, [gameInstance]);
```

### 3. 处理事件完成

当玩家完成操作后，通知事件系统：

```typescript
// 在事件UI组件中
const handleEventComplete = (result: any) => {
  if (!gameInstance || !currentEvent) return;
  
  // 通知事件系统事件已完成
  gameInstance.eventSystem.completeEvent(eventId, result);
  
  // 清除当前事件
  setCurrentEvent(null);
};
```

## 集成到现有逻辑

### 1. PlayerHand组件

在使用法术卡时，通过事件系统发布事件：

```typescript
// 发布法术卡事件
eventSystem.publishEvent({
  type: eventType,  // 根据法术卡效果确定事件类型
  playerId: player.id,
  spellCardId: cardId,
  options: {}
});
```

### 2. Tile格子效果

在处理格子效果时，可以使用事件系统等待玩家选择：

```typescript
// 在Tile子类中
async onStay(game: Game, player: Player): Promise<void> {
  // 发布格子事件并等待玩家选择
  const result = await game.eventSystem.waitForPlayerChoice({
    type: "TILE_TREASURE",
    playerId: player.id,
    tileData: {
      position: this.position,
      type: this.type
    }
  });
  
  // 根据玩家选择处理结果
  // ...
}
```

## 扩展新的事件类型

要添加新的事件类型，需要：

1. 在`GameEventType`中添加新的事件类型
2. 在`GameEventLayer.tsx`中添加对应的UI组件
3. 在相应的游戏逻辑中发布事件
4. 在UI组件中处理事件完成

## 优势

1. **解耦**: 游戏逻辑与UI渲染完全解耦
2. **可扩展**: 易于添加新的事件类型
3. **灵活性**: 支持同步和异步操作
4. **一致性**: 统一的事件处理机制
5. **可维护性**: 清晰的代码结构和职责分离
