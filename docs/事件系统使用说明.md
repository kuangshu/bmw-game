# 游戏事件系统使用说明

## 概述

本项目实现了一个基于事件驱动的游戏交互系统，用于处理游戏过程中各种需要等待玩家操作的场景。该系统通过发布/订阅模式，实现了游戏逻辑层与UI渲染层的解耦，使游戏流程更加灵活和可扩展。

## 核心组件

### 1. GameEventSystem (事件系统核心类)

位于 `src/entities/GameEventSystem.ts`，负责管理游戏中的各种异步事件和玩家交互。

#### 主要方法：

- `publishEvent<T>(event: Omit<GameEventData<T>, "timestamp" | "eventId">): string`: 发布事件并返回事件ID
- `subscribe<T>(eventType: GameEventType, callback: GameEventCallback<T>): void`: 订阅事件
- `unsubscribe<T>(eventType: GameEventType, callback: GameEventCallback<T>): void`: 取消订阅事件
- `waitForPlayerChoice<T, R>(event: Omit<GameEventData<T>, "timestamp" | "eventId">): Promise<R>`: 等待玩家选择并返回Promise
- `completeEvent<T>(eventId: string, result: T): void`: 完成事件处理并返回结果
- `getPendingEvent<T>(): GameEventData<T> | undefined`: 获取待处理事件
- `removeProcessedEvent(eventId?: string): void`: 移除已处理的事件
- `clearEvents(): void`: 清空所有事件

### 2. GameEventType (事件类型)

定义了各种游戏事件类型，位于 `src/entities/GameEventSystem.ts`：

- 法术卡事件：
  - `SPELL_FIX_DICE`: 定身术 - 指定骰子点数
  - `SPELL_SWAP_POSITION`: 交换位置 - 与其他玩家交换位置
  - `SPELL_EXTRA_TURN`: 额外回合 - 获得额外的行动回合

- BOSS战斗事件：
  - `BOSS_BATTLE_PLAY_CARDS`: BOSS战斗出牌 - 选择卡牌挑战BOSS

- 格子事件：
  - `TILE_TREASURE`: 宝箱格 - 触发抽卡事件
  - `TILE_REVERSE`: 反转格 - 改变移动方向
  - `TILE_SUPPLY`: 补给站 - 获得功能牌
  - `TILE_TELEPORT`: 传送格 - 传送到其他位置

- 游戏事件：
  - `GAME_OVER`: 游戏结束
  - `TURN_END`: 回合结束
  - `PLAYER_CHOICE`: 玩家选择
  - `PLAY_CARDS`: 出牌事件
  - `PLAYER_ROLE_SELECTION`: 玩家角色选择
  - `CUSTOM`: 自定义事件

### 3. GameEventData (事件数据)

包含事件的所有相关信息，使用泛型支持不同类型的事件数据：

```typescript
export interface GameEventData<T = any> {
  type: GameEventType;      // 事件类型
  playerId?: number;        // 玩家ID（可选）
  timestamp: number;        // 时间戳
  eventId: string;          // 事件唯一标识
  eventData?: T;            // 特定事件数据（泛型参数）
}
```

### 4. GameEventLayer (事件层组件)

位于 `src/components/GameEventLayer/GameEventLayer.tsx`，负责渲染事件UI和处理用户交互。

## 使用方法

### 1. 发布事件

在游戏逻辑中，当需要玩家操作时，发布相应事件：

```typescript
// 在Game类中
const eventSystem = this._eventSystem;
const eventId = eventSystem.publishEvent({
  type: "SPELL_FIX_DICE",
  playerId: player.id,
  eventData: {} // 可选的事件特定数据
});
```

### 2. 订阅事件

在UI组件中订阅感兴趣的事件类型：

```typescript
// 在GameEventLayer.tsx中
useEffect(() => {
  if (!gameInstance) return;

  const eventSystem = gameInstance.eventSystem;
  
  // 订阅法术卡事件
  const handleSpellFixDice = (eventData: GameEventData) => {
    // 处理定身术事件
    setCurrentEvent(eventData);
  };

  eventSystem.subscribe("SPELL_FIX_DICE", handleSpellFixDice);

  // 清理订阅
  return () => {
    eventSystem.unsubscribe("SPELL_FIX_DICE", handleSpellFixDice);
  };
}, [gameInstance]);
```

### 3. 等待玩家选择

使用 `waitForPlayerChoice` 方法等待玩家操作：

```typescript
// 在游戏逻辑中等待玩家选择
const result = await game.eventSystem.waitForPlayerChoice<
  SpellFixDicePayload[0],
  SpellFixDicePayload[1]
>({
  type: "SPELL_FIX_DICE",
  playerId: player.id,
  eventData: {}
});

// 处理玩家选择结果
console.log("玩家选择的骰子点数:", result.fixedValue);
```

### 4. 处理事件完成

当玩家完成操作后，通知事件系统：

```typescript
// 在事件UI组件中
const handleEventComplete = (result: any) => {
  if (!gameInstance || !currentEvent) return;
  
  // 通知事件系统事件已完成
  gameInstance.eventSystem.completeEvent(currentEvent.eventId, result);
  
  // 移除已处理的事件
  gameInstance.eventSystem.removeProcessedEvent(currentEvent.eventId);
  
  // 清除当前事件
  setCurrentEvent(null);
};
```

## 事件组件实现

每个事件类型都有对应的React组件，位于 `src/components/GameEventLayer/` 目录下：

- `SpellFixDiceEvent.tsx`: 定身术事件UI
- `SpellSwapPositionEvent.tsx`: 交换位置事件UI
- `SpellExtraTurnEvent.tsx`: 额外回合事件UI
- `BossBattlePlayCardsEvent.tsx`: BOSS战斗出牌事件UI
- `PlayerRoleSelectionEvent.tsx`: 玩家角色选择事件UI

### 事件组件示例

```typescript
// SpellFixDiceEvent.tsx
export type SpellFixDicePayload = [null, { fixedValue: number }];

interface SpellFixDiceEventProps {
  eventData: GameEventData<SpellFixDicePayload[0]>;
  onComplete: (result: SpellFixDicePayload[1]) => void;
}

const SpellFixDiceEvent: React.FC<SpellFixDiceEventProps> = ({
  onComplete,
}) => {
  // 组件实现...
  
  const handleSubmit = () => {
    // 计算骰子点数总和
    const totalSteps = dice1 + dice2;
    
    // 完成事件，返回固定的骰子点数
    onComplete({ fixedValue: totalSteps });
  };
  
  // UI渲染...
};
```

## 集成到现有逻辑

### 1. PlayerHand组件

在使用法术卡时，通过事件系统发布事件：

```typescript
// 发布法术卡事件
eventSystem.publishEvent({
  type: eventType,  // 根据法术卡效果确定事件类型
  playerId: player.id,
  eventData: {}     // 事件特定数据
});
```

### 2. Tile格子效果

在处理格子效果时，可以使用事件系统等待玩家选择：

```typescript
// 在Tile子类中
async onStay(game: Game, player: Player): Promise<void> {
  // 发布格子事件并等待玩家选择
  const result = await game.eventSystem.waitForPlayerChoice({
    type: "TILE_TREASURE",
    playerId: player.id,
    eventData: {
      position: this.position,
      type: this.type
    }
  });
  
  // 根据玩家选择处理结果
  // ...
}
```

### 3. BOSS战斗

BOSS战斗通过事件系统实现卡牌选择：

```typescript
// 在BossTile类中
private async handleBossBattle(game: Game, player: Player): Promise<void> {
  const playResult = await game.eventSystem.waitForPlayerChoice<
    BossBattlePlayCardsPayload[0],
    BossBattlePlayCardsPayload[1]
  >({
    type: "BOSS_BATTLE_PLAY_CARDS",
    playerId: player.id,
    eventData: { requirement: this.bossRequirement || 0 },
  });

  // 处理战斗结果
  if (playResult.defeatedBoss) {
    // 成功击败BOSS
  } else {
    // 未击败BOSS，撤退
  }
}
```

## 扩展新的事件类型

要添加新的事件类型，需要：

1. **在GameEventType中添加新的事件类型**：
   ```typescript
   export type GameEventType = 
     // ... 现有事件类型
     | "NEW_EVENT_TYPE"; // 新事件类型
   ```

2. **创建事件组件**：
   - 在 `src/components/GameEventLayer/` 目录下创建新的事件组件
   - 定义事件数据类型和组件接口

3. **在GameEventLayer.tsx中注册新事件**：
   ```typescript
   // 导入新的事件组件
   import NewEventComponent from "./NewEventComponent";
   
   // 在事件类型数组中添加新类型
   const eventTypes: GameEventType[] = [
     // ... 现有事件类型
     "NEW_EVENT_TYPE",
   ];
   
   // 在renderEventUI方法中添加渲染逻辑
   case "NEW_EVENT_TYPE":
     return (
       <NewEventComponent
         eventData={currentEvent}
         onComplete={handleEventComplete}
       />
     );
   ```

4. **在游戏逻辑中发布事件**：
   ```typescript
   game.eventSystem.publishEvent({
     type: "NEW_EVENT_TYPE",
     playerId: player.id,
     eventData: { /* 事件特定数据 */ }
   });
   ```

## 事件系统优势

1. **解耦**: 游戏逻辑与UI渲染完全解耦，提高代码可维护性
2. **可扩展**: 易于添加新的事件类型和对应的UI组件
3. **灵活性**: 支持同步和异步操作，适应各种游戏场景
4. **一致性**: 统一的事件处理机制，降低学习成本
5. **可维护性**: 清晰的代码结构和职责分离
6. **类型安全**: 使用TypeScript泛型确保事件数据的类型安全

## 最佳实践

1. **事件命名**: 使用清晰、一致的事件命名约定
2. **数据封装**: 将事件相关数据封装在eventData中，保持接口简洁
3. **错误处理**: 在事件组件中添加适当的错误处理和边界情况处理
4. **资源清理**: 确保在组件卸载时正确清理事件订阅
5. **类型定义**: 为每个事件类型定义明确的输入输出类型

## 示例：完整的事件流程

以下是一个完整的事件流程示例，展示从发布事件到处理结果的整个过程：

```typescript
// 1. 在游戏逻辑中发布事件
async function handleSpellCard(game: Game, player: Player, card: Card) {
  if (card.effect === "fix_dice") {
    // 等待玩家选择骰子点数
    const result = await game.eventSystem.waitForPlayerChoice<
      SpellFixDicePayload[0],
      SpellFixDicePayload[1]
    >({
      type: "SPELL_FIX_DICE",
      playerId: player.id,
      eventData: {}
    });
    
    // 应用玩家选择的结果
    game.processSteps(result.fixedValue);
  }
}

// 2. 在事件组件中处理用户交互
function SpellFixDiceEvent({ onComplete }: SpellFixDiceEventProps) {
  const [dice1, setDice1] = useState(1);
  const [dice2, setDice2] = useState(1);

  const handleSubmit = () => {
    const totalSteps = dice1 + dice2;
    onComplete({ fixedValue: totalSteps });
  };

  // UI渲染...
}

// 3. 在GameEventLayer中处理事件完成
function GameEventLayer() {
  const handleEventComplete = (result: any) => {
    if (!gameInstance || !currentEvent) return;
    
    // 通知事件系统事件已完成
    gameInstance.eventSystem.completeEvent(currentEvent.eventId, result);
    
    // 移除已处理的事件
    gameInstance.eventSystem.removeProcessedEvent(currentEvent.eventId);
    
    // 清除当前事件
    setCurrentEvent(null);
  };

  // 渲染逻辑...
}
```

通过这种事件驱动的方式，游戏逻辑和UI交互完全解耦，使得代码更加模块化和可维护。