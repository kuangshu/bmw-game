我需要重写处理骰子结果的函数，函数只需要一个参数即前进步数的数字，之后的处理逻辑如下：

1. 然后开始行动状态，并记录剩余的步数，步数需要数组来记录，因为在后续处理格子的步骤中可能增加步数。
2. 然后开始处理每段的步数，依次的步进，每个格子都需要处理完对应格子的效果才结束，并且不切换到下一个玩家
3. 如果当前处理的步数数字不为0的情况下，进入格子的效果是“路过”，当前处理的步数数字为0的时候所在格子的效果是“停留”。
4. 依次处理完每个格子的效果一直到记录步数的数组为空，行动状态就结束了。
5. 格子的处理函数可以新建一个函数。其中包含需要中断等玩家选择之后继续处理的逻辑，目前可暂不实现。

PlayerRole 有6个角色分别是： “天命人”，“四妹”，“猪八戒”，“大鸟姐姐”，“神偷大盗”，“奶昔大哥”，将 Player 当作一个基础类型，将 ROLE_TILE_HANDLERS 的配置当作 Player 的公共方法，每个角色都继承 Player，并各自实现自己的类似 ROLE_TILE_HANDLERS 的方法。

游戏过程中有很多需要等待玩家操作的场景，而且其返回值各不相同，能否设计一个方便 UI 渲染层和游戏控制类交互的方式，在游戏过程中发起一个action或者通知之后，UI根据发起的类型展示对应的操作界面，用户完成操作之后，游戏内控制逻辑可以根据操作结果继续没有完成的流程。请给我一个设计方案，如果需要安装新的依赖也列出清单。

在 GameEventSystem 中为 GameEventType 添加一个出牌事件，然后在 PlayerHand 中订阅该事件，当触发时所有的卡牌都是可选的，而且选择结束后，调用的是

添加事件牌堆，当玩家停留在宝箱格的时候，随机选一张大事件触发，只有注明玩家可保留卡牌会进入玩家手牌，然后使用后重新进入事件牌堆。触发事件完成后打乱牌堆顺序。大事件类型如下：

1. 可与场上任一玩家互换所有卡牌。
2. 下一关BOSS 的 PK 直接通关。（玩家可保留此卡）
3. 你随机舍弃一张卡牌。
4. 你与下一位玩家随机舍弃一张卡牌。
5. 每位玩家从功能卡堆中抽取一张卡牌。
6. 你与上一位玩家从功能卡堆中抽取一张卡牌。
7. 每位玩家随机舍弃一张卡牌。
8. 选择一位玩家进行扔骰子的PK，如果你获胜可以抽取对方一张卡牌，失败则不抽取。
   当前可只创建事件牌堆及事件卡与玩家和游戏数据交互的接口，不实现事件的实际效果，打上TODO的标记。

事件牌堆不设置弃牌堆，因为事件卡是从牌堆中选择一张生效，并不会离开牌堆，只有玩家可保留的卡牌会被放入玩家手牌，从牌堆离开。在玩家手牌中使用了事件卡后，事件卡牌重新回到事件牌堆。
抽取事件牌堆的方法应利用事件系统触发一个抽取事件卡的事件，对应的在 UI 部分将展示现在的事件牌堆，展示卡背不可见卡牌效果，供玩家选择。玩家选择了一张事件卡后，解决事件，并执行事件卡的效果。
事件卡的执行效果结束后，打乱事件牌堆顺序。

使用 thinking 规划此任务，我需要完成 SwapAllCardsEventCard 中的执行逻辑。

1. 首选触发一个选择用户的事件，等待事件结束可能返回一个玩家 id。
   - 选择用户事件需要一个处理事件的 UI 组件，组件中展示除了当前玩家之外的所有玩家，玩家可以选择一个玩家后确定，返回该玩家的 id。或者选择放弃。
   - 玩家展示角色和剩余的手牌数量。
   - 可以通过点击选中和反选。
2. 在事件结束后，获取结果。如果没有返回 id 则说明玩家放弃交换，处理逻辑结束。如果获取返回玩家 id ，则交换两个玩家所有的卡牌。然后处理逻辑结束。

我想让选择玩家的组件更加通用。修改组件内和交换卡牌相关的文案，让组件更加通用。
为事件数据添加一个说明文字，方便在选择玩家组件上面展示。
为事件数据另外添加一个能否放弃的 boolean 值，只有当传入的事件数据中包含可以放弃的 boolean 时才可以选择放弃。

---

我需要完成 RandomDiscardEventCard 中的执行逻辑。

1. 首选触发一个玩家选择卡牌的事件，事件数据涵盖了卡牌数组，是否遮挡，选择数量等信息，等待事件结束返回一个卡牌 id 的数组。
   - 选择卡牌事件需要一个处理事件的 UI 组件，组件中展示当前玩家的卡牌，根据事件携带的数据来渲染，玩家选择后解决事件。
   - 可以通过点击选中和反选。
2. 在事件结束后，获取结果。将选中的卡牌从玩家手牌中去掉。
   - Game 中实现一个弃掉玩家卡牌的方法 `(player, cardIds) => void`，从玩家手中弃掉指定的卡牌，并把卡牌重新加入弃牌堆。弃牌逻辑都使用该方法。
3. 根据上面的修改完成 NextPlayerDiscardEventCard 和 AllPlayersDiscardEventCard 的逻辑。

我需要完成 BossBattlePassEventCard 中的执行逻辑。
首先将此卡放入玩家手牌，由于事件卡和功能卡类型不太一样，可以为 Card 的添加一个 `type` 属性，用来区分事件卡和功能卡，事件卡的 `type` 为 `event`，能量为 99。
此卡牌只有在 BossBattlePlayCardsEvent 事件中选中使用，需要修改 BossBattlePlayCardsEvent 中判断选中和计算能量的逻辑。
事件完成后，需要修改 BossTile 中的后续处理逻辑，玩家使用卡牌中的功能卡牌可以使用 Game 中的方法弃掉牌。
修改 Game.discardCards 方法，弃牌从玩家手牌中移除后，如果是事件卡牌，并回到事件卡堆，功能卡牌则回到弃牌堆。

---

使用 thinking 规划此任务，完成 DiceBattleStealEventCard 中的执行逻辑。流程如下：

1. 触发一个选择玩家的事件，等待事件结束可能返回一个玩家 id。如果选择玩家无卡牌，则直接结束。
2. 当前玩家触发一个扔骰子事件。
   - 扔骰子事件需要一个处理事件的 UI 组件，新建组件有一个扔骰子的按钮，和一个骰子结果的展示区域。点击按钮生成 2 个 1-6 的骰子结果。展示骰子结果之后完成事件。
3. 换到选中的玩家触发一个扔骰子事件。处理同上。
4. 拿到两个玩家扔骰子的结果进行比较。
   - 如果当前玩家的骰子结果更大，触发一个选中卡牌的事件，将选中玩家的所有卡牌放入到选择池子，限定选择一张。选择完成后，将选中的卡牌从选中玩家手牌中移除，并放入当前玩家手牌。
   - 如果当前玩家的骰子结果更小，或骰子结果相等，则当前玩家不获得对方的卡牌。
